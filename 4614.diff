diff --git a/perf_takehome.py b/perf_takehome.py
index 4188190..7b59495 100644
--- a/perf_takehome.py
+++ b/perf_takehome.py
@@ -46,11 +46,12 @@ class KernelBuilder:
         return DebugInfo(scratch_map=self.scratch_debug)
 
     def build(self, slots: list[tuple[Engine, tuple]], vliw: bool = False):
-        # Simple slot packing that just uses one slot per instruction bundle
-        instrs = []
-        for engine, slot in slots:
-            instrs.append({engine: [slot]})
-        return instrs
+        if not vliw:
+            instrs = []
+            for engine, slot in slots:
+                instrs.append({engine: [slot]})
+            return instrs
+        return self._pack_slots(slots)
 
     def add(self, engine, slot):
         self.instrs.append({engine: [slot]})
@@ -64,10 +65,13 @@ class KernelBuilder:
         assert self.scratch_ptr <= SCRATCH_SIZE, "Out of scratch space"
         return addr
 
-    def scratch_const(self, val, name=None):
+    def scratch_const(self, val, name=None, slots=None):
         if val not in self.const_map:
             addr = self.alloc_scratch(name)
-            self.add("load", ("const", addr, val))
+            if slots is None:
+                self.add("load", ("const", addr, val))
+            else:
+                slots.append(("load", ("const", addr, val)))
             self.const_map[val] = addr
         return self.const_map[val]
 
@@ -82,93 +86,490 @@ class KernelBuilder:
 
         return slots
 
+    def build_vector_hash(self, val_hash_vec, tmp_vec1, tmp_vec2):
+        slots = []
+        const_addr = self.alloc_scratch("hash_consts", len(HASH_STAGES) * 2)
+        
+        for hi, (op1, val1, op2, op3, val3) in enumerate(HASH_STAGES):
+            self.add("load", ("const", const_addr + hi * 2, val1))
+            self.add("load", ("const", const_addr + hi * 2 + 1, val3))
+        
+        for hi, (op1, val1, op2, op3, val3) in enumerate(HASH_STAGES):
+            const1 = const_addr + hi * 2
+            const3 = const_addr + hi * 2 + 1
+            slots.append(("alu", ("vbroadcast", tmp_vec1, const1)))
+            slots.append(("alu", ("vbroadcast", tmp_vec2, const3)))
+            slots.append(("valu", (op1, tmp_vec1, val_hash_vec, tmp_vec1)))
+            slots.append(("valu", (op3, tmp_vec2, val_hash_vec, tmp_vec2)))
+            slots.append(("valu", (op2, val_hash_vec, tmp_vec1, tmp_vec2)))
+        
+        return slots
+
+    def _add_range(self, out, start, length):
+        for i in range(length):
+            out.add(start + i)
+
+    def _slot_rw(self, engine, slot):
+        reads = set()
+        writes = set()
+        if engine == "alu":
+            if len(slot) == 4:
+                _op, dest, a1, a2 = slot
+                reads.update([a1, a2])
+                writes.add(dest)
+            elif len(slot) == 3:
+                _op, dest, a1 = slot
+                reads.add(a1)
+                writes.add(dest)
+            else:
+                pass
+        elif engine == "valu":
+            match slot:
+                case ("vbroadcast", dest, src):
+                    reads.add(src)
+                    self._add_range(writes, dest, VLEN)
+                case ("multiply_add", dest, a, b, c):
+                    self._add_range(reads, a, VLEN)
+                    self._add_range(reads, b, VLEN)
+                    self._add_range(reads, c, VLEN)
+                    self._add_range(writes, dest, VLEN)
+                case (_op, dest, a1, a2):
+                    self._add_range(reads, a1, VLEN)
+                    self._add_range(reads, a2, VLEN)
+                    self._add_range(writes, dest, VLEN)
+        elif engine == "load":
+            match slot:
+                case ("load", dest, addr):
+                    reads.add(addr)
+                    writes.add(dest)
+                case ("load_offset", dest, addr, offset):
+                    reads.add(addr + offset)
+                    writes.add(dest + offset)
+                case ("vload", dest, addr):
+                    reads.add(addr)
+                    self._add_range(writes, dest, VLEN)
+                case ("const", dest, _val):
+                    writes.add(dest)
+        elif engine == "store":
+            match slot:
+                case ("store", addr, src):
+                    reads.update([addr, src])
+                case ("vstore", addr, src):
+                    reads.add(addr)
+                    self._add_range(reads, src, VLEN)
+        elif engine == "flow":
+            match slot:
+                case ("select", dest, cond, a, b):
+                    reads.update([cond, a, b])
+                    writes.add(dest)
+                case ("add_imm", dest, a, _imm):
+                    reads.add(a)
+                    writes.add(dest)
+                case ("vselect", dest, cond, a, b):
+                    self._add_range(reads, cond, VLEN)
+                    self._add_range(reads, a, VLEN)
+                    self._add_range(reads, b, VLEN)
+                    self._add_range(writes, dest, VLEN)
+                case ("cond_jump", cond, addr):
+                    reads.update([cond, addr])
+                case ("cond_jump_rel", cond, _offset):
+                    reads.add(cond)
+                case ("jump", addr):
+                    reads.add(addr)
+                case ("jump_indirect", addr):
+                    reads.add(addr)
+                case ("coreid", dest):
+                    writes.add(dest)
+                case ("trace_write", val):
+                    reads.add(val)
+                case ("pause",):
+                    pass
+                case ("halt",):
+                    pass
+        return reads, writes
+
+    def _pack_slots(self, slots: list[tuple[Engine, tuple]]):
+        instrs = []
+        bundle = {}
+        bundle_writes = set()
+        engine_counts = defaultdict(int)
+
+        def flush_bundle():
+            nonlocal bundle, bundle_writes, engine_counts
+            if bundle:
+                instrs.append(bundle)
+                bundle = {}
+                bundle_writes = set()
+                engine_counts = defaultdict(int)
+
+        for engine, slot in slots:
+            reads, writes = self._slot_rw(engine, slot)
+            if (
+                engine_counts[engine] >= SLOT_LIMITS[engine]
+                or reads & bundle_writes
+                or writes & bundle_writes
+            ):
+                flush_bundle()
+            bundle.setdefault(engine, []).append(slot)
+            engine_counts[engine] += 1
+            bundle_writes.update(writes)
+
+        flush_bundle()
+        return instrs
+
     def build_kernel(
         self, forest_height: int, n_nodes: int, batch_size: int, rounds: int
     ):
         """
-        Like reference_kernel2 but building actual instructions.
-        Scalar implementation using only scalar ALU and load/store.
+        Optimized kernel with inverted loop order: batch-outer, round-inner.
+        This keeps data in registers across all 16 rounds per batch.
         """
+        init_slots = []
         tmp1 = self.alloc_scratch("tmp1")
-        tmp2 = self.alloc_scratch("tmp2")
-        tmp3 = self.alloc_scratch("tmp3")
-        # Scratch space addresses
-        init_vars = [
-            "rounds",
-            "n_nodes",
-            "batch_size",
-            "forest_height",
-            "forest_values_p",
-            "inp_indices_p",
-            "inp_values_p",
+
+        # Scalar constants
+        zero_const = self.scratch_const(0, "zero", init_slots)
+        one_const = self.scratch_const(1, "one", init_slots)
+        vlen_const = self.scratch_const(VLEN, "vlen", init_slots)
+        vlen4_const = self.scratch_const(VLEN * 4, "vlen4", init_slots)
+        n_nodes_const = self.scratch_const(n_nodes, "n_nodes", init_slots)
+
+        forest_values_p = self.scratch_const(7, "forest_values_p", init_slots)
+        inp_indices_p = self.scratch_const(7 + n_nodes, "inp_indices_p", init_slots)
+        inp_values_p = self.scratch_const(7 + n_nodes + batch_size, "inp_values_p", init_slots)
+
+        # Loop counters
+        round_counter = self.alloc_scratch("round_counter")
+        batch_counter = self.alloc_scratch("batch_counter")
+        max_rounds = self.scratch_const(rounds, "max_rounds", init_slots)
+        batch_end = self.scratch_const(batch_size, "batch_end", init_slots)
+
+        # Pointers for 4 vectors
+        idx_ptr0 = self.alloc_scratch("idx_ptr0")
+        val_ptr0 = self.alloc_scratch("val_ptr0")
+        idx_ptr1 = self.alloc_scratch("idx_ptr1")
+        val_ptr1 = self.alloc_scratch("val_ptr1")
+        idx_ptr2 = self.alloc_scratch("idx_ptr2")
+        val_ptr2 = self.alloc_scratch("val_ptr2")
+        idx_ptr3 = self.alloc_scratch("idx_ptr3")
+        val_ptr3 = self.alloc_scratch("val_ptr3")
+
+        # Vector registers for 4 batches
+        idx_vec0 = self.alloc_scratch("idx_vec0", VLEN)
+        idx_vec1 = self.alloc_scratch("idx_vec1", VLEN)
+        idx_vec2 = self.alloc_scratch("idx_vec2", VLEN)
+        idx_vec3 = self.alloc_scratch("idx_vec3", VLEN)
+        val_vec0 = self.alloc_scratch("val_vec0", VLEN)
+        val_vec1 = self.alloc_scratch("val_vec1", VLEN)
+        val_vec2 = self.alloc_scratch("val_vec2", VLEN)
+        val_vec3 = self.alloc_scratch("val_vec3", VLEN)
+        node_vec0 = self.alloc_scratch("node_vec0", VLEN)
+        node_vec1 = self.alloc_scratch("node_vec1", VLEN)
+        node_vec2 = self.alloc_scratch("node_vec2", VLEN)
+        node_vec3 = self.alloc_scratch("node_vec3", VLEN)
+        addr_vec0 = self.alloc_scratch("addr_vec0", VLEN)
+        addr_vec1 = self.alloc_scratch("addr_vec1", VLEN)
+        addr_vec2 = self.alloc_scratch("addr_vec2", VLEN)
+        addr_vec3 = self.alloc_scratch("addr_vec3", VLEN)
+        tmp_vec0 = self.alloc_scratch("tmp_vec0", VLEN)
+        tmp_vec1 = self.alloc_scratch("tmp_vec1", VLEN)
+        tmp_vec2 = self.alloc_scratch("tmp_vec2", VLEN)
+        tmp_vec3 = self.alloc_scratch("tmp_vec3", VLEN)
+        tmp2_vec0 = self.alloc_scratch("tmp2_vec0", VLEN)
+        tmp2_vec1 = self.alloc_scratch("tmp2_vec1", VLEN)
+        tmp2_vec2 = self.alloc_scratch("tmp2_vec2", VLEN)
+        tmp2_vec3 = self.alloc_scratch("tmp2_vec3", VLEN)
+        cond_vec0 = self.alloc_scratch("cond_vec0", VLEN)
+        cond_vec1 = self.alloc_scratch("cond_vec1", VLEN)
+        cond_vec2 = self.alloc_scratch("cond_vec2", VLEN)
+        cond_vec3 = self.alloc_scratch("cond_vec3", VLEN)
+
+        # Constant vectors
+        forest_base_vec = self.alloc_scratch("forest_base_vec", VLEN)
+        n_nodes_vec = self.alloc_scratch("n_nodes_vec", VLEN)
+        one_vec = self.alloc_scratch("one_vec", VLEN)
+
+        init_slots.append(("valu", ("vbroadcast", forest_base_vec, forest_values_p)))
+        init_slots.append(("valu", ("vbroadcast", n_nodes_vec, n_nodes_const)))
+        init_slots.append(("valu", ("vbroadcast", one_vec, one_const)))
+
+        # Pre-broadcast hash constants
+        hash_const_vecs = []
+        for op1, val1, op2, op3, val3 in HASH_STAGES:
+            const1 = self.scratch_const(val1, slots=init_slots)
+            const3 = self.scratch_const(val3, slots=init_slots)
+            const1_vec = self.alloc_scratch(length=VLEN)
+            const3_vec = self.alloc_scratch(length=VLEN)
+            init_slots.append(("valu", ("vbroadcast", const1_vec, const1)))
+            init_slots.append(("valu", ("vbroadcast", const3_vec, const3)))
+            hash_const_vecs.append((op1, op2, op3, const1_vec, const3_vec))
+
+        init_slots.append(("flow", ("pause",)))
+
+        # Initialize round counter
+        init_slots.append(("load", ("const", round_counter, 0)))
+
+        # Pack and add init instructions
+        self.instrs.extend(self._pack_slots(init_slots))
+
+        # NEW STRUCTURE: Batch-outer, Round-inner
+        # This keeps data in registers for all 16 rounds
+
+        # Initialize pointers
+        batch_setup = [
+            ("alu", ("+", idx_ptr0, inp_indices_p, zero_const)),
+            ("alu", ("+", val_ptr0, inp_values_p, zero_const)),
+            ("load", ("const", batch_counter, 0)),
         ]
-        for v in init_vars:
-            self.alloc_scratch(v, 1)
-        for i, v in enumerate(init_vars):
-            self.add("load", ("const", tmp1, i))
-            self.add("load", ("load", self.scratch[v], tmp1))
-
-        zero_const = self.scratch_const(0)
-        one_const = self.scratch_const(1)
-        two_const = self.scratch_const(2)
-
-        # Pause instructions are matched up with yield statements in the reference
-        # kernel to let you debug at intermediate steps. The testing harness in this
-        # file requires these match up to the reference kernel's yields, but the
-        # submission harness ignores them.
+        self.instrs.extend(self._pack_slots(batch_setup))
+
+        # Batch loop start (outer loop)
+        batch_loop_target = len(self.instrs)
+
+        # Setup pointers for all 4 vectors (once per batch)
+        ptr_setup = [
+            ("alu", ("+", idx_ptr1, idx_ptr0, vlen_const)),
+            ("alu", ("+", val_ptr1, val_ptr0, vlen_const)),
+            ("alu", ("+", idx_ptr2, idx_ptr1, vlen_const)),
+            ("alu", ("+", val_ptr2, val_ptr1, vlen_const)),
+            ("alu", ("+", idx_ptr3, idx_ptr2, vlen_const)),
+            ("alu", ("+", val_ptr3, val_ptr2, vlen_const)),
+        ]
+        self.instrs.extend(self._pack_slots(ptr_setup))
+
+        # Load all 4 vectors (once per batch)
+        load_slots = [
+            ("load", ("vload", idx_vec0, idx_ptr0)),
+            ("load", ("vload", val_vec0, val_ptr0)),
+            ("load", ("vload", idx_vec1, idx_ptr1)),
+            ("load", ("vload", val_vec1, val_ptr1)),
+            ("load", ("vload", idx_vec2, idx_ptr2)),
+            ("load", ("vload", val_vec2, val_ptr2)),
+            ("load", ("vload", idx_vec3, idx_ptr3)),
+            ("load", ("vload", val_vec3, val_ptr3)),
+            ("load", ("const", round_counter, 0)),
+        ]
+        self.instrs.extend(self._pack_slots(load_slots))
+
+        # === ROUND 0 SPECIAL CASE ===
+        # All elements start with idx=0, so we can load tree[0] once and broadcast
+        # instead of doing 32 gather loads per batch
+        tree_node_0 = self.alloc_scratch("tree_node_0")
+        round0_body = []
+        # Load tree[0] - forest_values_p points to the tree base, tree[0] is at that address
+        round0_body.append(("load", ("load", tree_node_0, forest_values_p)))
+        # Broadcast to all node vectors
+        round0_body.append(("valu", ("vbroadcast", node_vec0, tree_node_0)))
+        round0_body.append(("valu", ("vbroadcast", node_vec1, tree_node_0)))
+        round0_body.append(("valu", ("vbroadcast", node_vec2, tree_node_0)))
+        round0_body.append(("valu", ("vbroadcast", node_vec3, tree_node_0)))
+        # XOR
+        round0_body.append(("valu", ("^", val_vec0, val_vec0, node_vec0)))
+        round0_body.append(("valu", ("^", val_vec1, val_vec1, node_vec1)))
+        round0_body.append(("valu", ("^", val_vec2, val_vec2, node_vec2)))
+        round0_body.append(("valu", ("^", val_vec3, val_vec3, node_vec3)))
+        # Hash computation
+        for op1, op2, op3, const1_vec, const3_vec in hash_const_vecs:
+            round0_body.append(("valu", (op1, tmp_vec0, val_vec0, const1_vec)))
+            round0_body.append(("valu", (op3, tmp2_vec0, val_vec0, const3_vec)))
+            round0_body.append(("valu", (op1, tmp_vec1, val_vec1, const1_vec)))
+            round0_body.append(("valu", (op3, tmp2_vec1, val_vec1, const3_vec)))
+            round0_body.append(("valu", (op1, tmp_vec2, val_vec2, const1_vec)))
+            round0_body.append(("valu", (op3, tmp2_vec2, val_vec2, const3_vec)))
+            round0_body.append(("valu", (op2, val_vec0, tmp_vec0, tmp2_vec0)))
+            round0_body.append(("valu", (op2, val_vec1, tmp_vec1, tmp2_vec1)))
+            round0_body.append(("valu", (op1, tmp_vec3, val_vec3, const1_vec)))
+            round0_body.append(("valu", (op3, tmp2_vec3, val_vec3, const3_vec)))
+            round0_body.append(("valu", (op2, val_vec2, tmp_vec2, tmp2_vec2)))
+            round0_body.append(("valu", (op2, val_vec3, tmp_vec3, tmp2_vec3)))
+        # Index calculation: idx = 2*idx + (val & 1) + 1
+        # Since idx starts at 0: idx = 0*2 + (val & 1) + 1 = (val & 1) + 1
+        round0_body.append(("valu", ("&", idx_vec0, val_vec0, one_vec)))
+        round0_body.append(("valu", ("&", idx_vec1, val_vec1, one_vec)))
+        round0_body.append(("valu", ("&", idx_vec2, val_vec2, one_vec)))
+        round0_body.append(("valu", ("&", idx_vec3, val_vec3, one_vec)))
+        round0_body.append(("valu", ("+", idx_vec0, idx_vec0, one_vec)))
+        round0_body.append(("valu", ("+", idx_vec1, idx_vec1, one_vec)))
+        round0_body.append(("valu", ("+", idx_vec2, idx_vec2, one_vec)))
+        round0_body.append(("valu", ("+", idx_vec3, idx_vec3, one_vec)))
+        # No wrap needed for round 0 since idx <= 2 and n_nodes is much larger
+        self.instrs.extend(self._pack_slots(round0_body))
+
+        # === ROUND 1 SPECIAL CASE ===
+        # After round 0, idx is either 1 or 2. Load tree[1] and tree[2], then vselect.
+        tree_addr_tmp = self.alloc_scratch("tree_addr_tmp")
+        tree_node_1 = self.alloc_scratch("tree_node_1")
+        tree_node_2 = self.alloc_scratch("tree_node_2")
+        tree_vec_1 = self.alloc_scratch("tree_vec_1", VLEN)
+        tree_vec_2 = self.alloc_scratch("tree_vec_2", VLEN)
+        two_const = self.alloc_scratch("two_const")
+        round1_body = []
+        # Load two_const, then load tree[1] and tree[2]
+        round1_body.append(("load", ("const", two_const, 2)))
+        round1_body.append(("alu", ("+", tree_addr_tmp, forest_values_p, one_const)))
+        round1_body.append(("load", ("load", tree_node_1, tree_addr_tmp)))
+        round1_body.append(("alu", ("+", tree_addr_tmp, forest_values_p, two_const)))
+        round1_body.append(("load", ("load", tree_node_2, tree_addr_tmp)))
+        # Broadcast to vectors
+        round1_body.append(("valu", ("vbroadcast", tree_vec_1, tree_node_1)))
+        round1_body.append(("valu", ("vbroadcast", tree_vec_2, tree_node_2)))
+        # vselect based on idx: if idx == 2, use tree_vec_2, else tree_vec_1
+        # cond = (idx == 2) ? 1 : 0
+        two_vec = self.alloc_scratch("two_vec", VLEN)
+        round1_body.append(("valu", ("vbroadcast", two_vec, two_const)))
+        round1_body.append(("valu", ("==", cond_vec0, idx_vec0, two_vec)))
+        round1_body.append(("valu", ("==", cond_vec1, idx_vec1, two_vec)))
+        round1_body.append(("valu", ("==", cond_vec2, idx_vec2, two_vec)))
+        round1_body.append(("valu", ("==", cond_vec3, idx_vec3, two_vec)))
+        # vselect: node_vec = cond ? tree_vec_2 : tree_vec_1
+        round1_body.append(("flow", ("vselect", node_vec0, cond_vec0, tree_vec_2, tree_vec_1)))
+        round1_body.append(("flow", ("vselect", node_vec1, cond_vec1, tree_vec_2, tree_vec_1)))
+        round1_body.append(("flow", ("vselect", node_vec2, cond_vec2, tree_vec_2, tree_vec_1)))
+        round1_body.append(("flow", ("vselect", node_vec3, cond_vec3, tree_vec_2, tree_vec_1)))
+        # XOR
+        round1_body.append(("valu", ("^", val_vec0, val_vec0, node_vec0)))
+        round1_body.append(("valu", ("^", val_vec1, val_vec1, node_vec1)))
+        round1_body.append(("valu", ("^", val_vec2, val_vec2, node_vec2)))
+        round1_body.append(("valu", ("^", val_vec3, val_vec3, node_vec3)))
+        # Hash computation
+        for op1, op2, op3, const1_vec, const3_vec in hash_const_vecs:
+            round1_body.append(("valu", (op1, tmp_vec0, val_vec0, const1_vec)))
+            round1_body.append(("valu", (op3, tmp2_vec0, val_vec0, const3_vec)))
+            round1_body.append(("valu", (op1, tmp_vec1, val_vec1, const1_vec)))
+            round1_body.append(("valu", (op3, tmp2_vec1, val_vec1, const3_vec)))
+            round1_body.append(("valu", (op1, tmp_vec2, val_vec2, const1_vec)))
+            round1_body.append(("valu", (op3, tmp2_vec2, val_vec2, const3_vec)))
+            round1_body.append(("valu", (op2, val_vec0, tmp_vec0, tmp2_vec0)))
+            round1_body.append(("valu", (op2, val_vec1, tmp_vec1, tmp2_vec1)))
+            round1_body.append(("valu", (op1, tmp_vec3, val_vec3, const1_vec)))
+            round1_body.append(("valu", (op3, tmp2_vec3, val_vec3, const3_vec)))
+            round1_body.append(("valu", (op2, val_vec2, tmp_vec2, tmp2_vec2)))
+            round1_body.append(("valu", (op2, val_vec3, tmp_vec3, tmp2_vec3)))
+        # Index calculation: idx = 2*idx + (val & 1) + 1
+        round1_body.append(("valu", ("&", tmp_vec0, val_vec0, one_vec)))
+        round1_body.append(("valu", ("&", tmp_vec1, val_vec1, one_vec)))
+        round1_body.append(("valu", ("&", tmp_vec2, val_vec2, one_vec)))
+        round1_body.append(("valu", ("&", tmp_vec3, val_vec3, one_vec)))
+        round1_body.append(("valu", ("+", tmp_vec0, tmp_vec0, one_vec)))
+        round1_body.append(("valu", ("+", tmp_vec1, tmp_vec1, one_vec)))
+        round1_body.append(("valu", ("+", tmp_vec2, tmp_vec2, one_vec)))
+        round1_body.append(("valu", ("+", tmp_vec3, tmp_vec3, one_vec)))
+        round1_body.append(("valu", ("+", idx_vec0, idx_vec0, idx_vec0)))
+        round1_body.append(("valu", ("+", idx_vec1, idx_vec1, idx_vec1)))
+        round1_body.append(("valu", ("+", idx_vec2, idx_vec2, idx_vec2)))
+        round1_body.append(("valu", ("+", idx_vec3, idx_vec3, idx_vec3)))
+        round1_body.append(("valu", ("+", idx_vec0, idx_vec0, tmp_vec0)))
+        round1_body.append(("valu", ("+", idx_vec1, idx_vec1, tmp_vec1)))
+        round1_body.append(("valu", ("+", idx_vec2, idx_vec2, tmp_vec2)))
+        round1_body.append(("valu", ("+", idx_vec3, idx_vec3, tmp_vec3)))
+        # No wrap needed for round 1 since idx <= 6 and n_nodes is much larger
+        # Set round_counter = 2 for the remaining 14 rounds
+        round1_body.append(("load", ("const", round_counter, 2)))
+        self.instrs.extend(self._pack_slots(round1_body))
+
+        # Round loop start (inner loop) - for rounds 2-15
+        round_loop_target = len(self.instrs)
+
+        # Build round body - compute and update in registers
+        round_body = []
+        # Compute gather addresses
+        round_body.append(("valu", ("+", addr_vec0, idx_vec0, forest_base_vec)))
+        round_body.append(("valu", ("+", addr_vec1, idx_vec1, forest_base_vec)))
+        round_body.append(("valu", ("+", addr_vec2, idx_vec2, forest_base_vec)))
+        round_body.append(("valu", ("+", addr_vec3, idx_vec3, forest_base_vec)))
+
+        # Gather loads (32 loads, 2 per cycle = 16 cycles)
+        for vi in range(VLEN):
+            round_body.append(("load", ("load_offset", node_vec0, addr_vec0, vi)))
+            round_body.append(("load", ("load_offset", node_vec1, addr_vec1, vi)))
+        for vi in range(VLEN):
+            round_body.append(("load", ("load_offset", node_vec2, addr_vec2, vi)))
+            round_body.append(("load", ("load_offset", node_vec3, addr_vec3, vi)))
+
+        # XOR
+        round_body.append(("valu", ("^", val_vec0, val_vec0, node_vec0)))
+        round_body.append(("valu", ("^", val_vec1, val_vec1, node_vec1)))
+        round_body.append(("valu", ("^", val_vec2, val_vec2, node_vec2)))
+        round_body.append(("valu", ("^", val_vec3, val_vec3, node_vec3)))
+
+        # Hash computation
+        for op1, op2, op3, const1_vec, const3_vec in hash_const_vecs:
+            round_body.append(("valu", (op1, tmp_vec0, val_vec0, const1_vec)))
+            round_body.append(("valu", (op3, tmp2_vec0, val_vec0, const3_vec)))
+            round_body.append(("valu", (op1, tmp_vec1, val_vec1, const1_vec)))
+            round_body.append(("valu", (op3, tmp2_vec1, val_vec1, const3_vec)))
+            round_body.append(("valu", (op1, tmp_vec2, val_vec2, const1_vec)))
+            round_body.append(("valu", (op3, tmp2_vec2, val_vec2, const3_vec)))
+            round_body.append(("valu", (op2, val_vec0, tmp_vec0, tmp2_vec0)))
+            round_body.append(("valu", (op2, val_vec1, tmp_vec1, tmp2_vec1)))
+            round_body.append(("valu", (op1, tmp_vec3, val_vec3, const1_vec)))
+            round_body.append(("valu", (op3, tmp2_vec3, val_vec3, const3_vec)))
+            round_body.append(("valu", (op2, val_vec2, tmp_vec2, tmp2_vec2)))
+            round_body.append(("valu", (op2, val_vec3, tmp_vec3, tmp2_vec3)))
+
+        # Index calculation: idx = 2*idx + (val & 1) + 1
+        round_body.append(("valu", ("&", tmp_vec0, val_vec0, one_vec)))
+        round_body.append(("valu", ("&", tmp_vec1, val_vec1, one_vec)))
+        round_body.append(("valu", ("&", tmp_vec2, val_vec2, one_vec)))
+        round_body.append(("valu", ("&", tmp_vec3, val_vec3, one_vec)))
+        round_body.append(("valu", ("+", tmp_vec0, tmp_vec0, one_vec)))
+        round_body.append(("valu", ("+", tmp_vec1, tmp_vec1, one_vec)))
+        round_body.append(("valu", ("+", tmp_vec2, tmp_vec2, one_vec)))
+        round_body.append(("valu", ("+", tmp_vec3, tmp_vec3, one_vec)))
+        round_body.append(("valu", ("+", idx_vec0, idx_vec0, idx_vec0)))
+        round_body.append(("valu", ("+", idx_vec1, idx_vec1, idx_vec1)))
+        round_body.append(("valu", ("+", idx_vec2, idx_vec2, idx_vec2)))
+        round_body.append(("valu", ("+", idx_vec3, idx_vec3, idx_vec3)))
+        round_body.append(("valu", ("+", idx_vec0, idx_vec0, tmp_vec0)))
+        round_body.append(("valu", ("+", idx_vec1, idx_vec1, tmp_vec1)))
+        round_body.append(("valu", ("+", idx_vec2, idx_vec2, tmp_vec2)))
+        round_body.append(("valu", ("+", idx_vec3, idx_vec3, tmp_vec3)))
+
+        # Wrap: idx = idx * (idx < n_nodes)
+        round_body.append(("valu", ("<", cond_vec0, idx_vec0, n_nodes_vec)))
+        round_body.append(("valu", ("<", cond_vec1, idx_vec1, n_nodes_vec)))
+        round_body.append(("valu", ("<", cond_vec2, idx_vec2, n_nodes_vec)))
+        round_body.append(("valu", ("<", cond_vec3, idx_vec3, n_nodes_vec)))
+        round_body.append(("valu", ("*", idx_vec0, idx_vec0, cond_vec0)))
+        round_body.append(("valu", ("*", idx_vec1, idx_vec1, cond_vec1)))
+        round_body.append(("valu", ("*", idx_vec2, idx_vec2, cond_vec2)))
+        round_body.append(("valu", ("*", idx_vec3, idx_vec3, cond_vec3)))
+
+        # Round loop control (no store - keep in registers!)
+        round_body.append(("alu", ("+", round_counter, round_counter, one_const)))
+        round_body.append(("alu", ("<", tmp1, round_counter, max_rounds)))
+
+        # Pack and add round body
+        self.instrs.extend(self._pack_slots(round_body))
+
+        # Round loop jump
+        round_jump_src = len(self.instrs) + 1
+        round_jump_offset = round_loop_target - round_jump_src
+        self.add("flow", ("cond_jump_rel", tmp1, round_jump_offset))
+
+        # Store results (once per batch, after all 16 rounds)
+        store_slots = [
+            ("store", ("vstore", idx_ptr0, idx_vec0)),
+            ("store", ("vstore", val_ptr0, val_vec0)),
+            ("store", ("vstore", idx_ptr1, idx_vec1)),
+            ("store", ("vstore", val_ptr1, val_vec1)),
+            ("store", ("vstore", idx_ptr2, idx_vec2)),
+            ("store", ("vstore", val_ptr2, val_vec2)),
+            ("store", ("vstore", idx_ptr3, idx_vec3)),
+            ("store", ("vstore", val_ptr3, val_vec3)),
+            ("alu", ("+", idx_ptr0, idx_ptr0, vlen4_const)),
+            ("alu", ("+", val_ptr0, val_ptr0, vlen4_const)),
+            ("alu", ("+", batch_counter, batch_counter, vlen4_const)),
+            ("alu", ("<", tmp1, batch_counter, batch_end)),
+        ]
+        self.instrs.extend(self._pack_slots(store_slots))
+
+        # Batch loop jump
+        batch_jump_src = len(self.instrs) + 1
+        batch_jump_offset = batch_loop_target - batch_jump_src
+        self.add("flow", ("cond_jump_rel", tmp1, batch_jump_offset))
+
         self.add("flow", ("pause",))
-        # Any debug engine instruction is ignored by the submission simulator
-        self.add("debug", ("comment", "Starting loop"))
-
-        body = []  # array of slots
-
-        # Scalar scratch registers
-        tmp_idx = self.alloc_scratch("tmp_idx")
-        tmp_val = self.alloc_scratch("tmp_val")
-        tmp_node_val = self.alloc_scratch("tmp_node_val")
-        tmp_addr = self.alloc_scratch("tmp_addr")
-
-        for round in range(rounds):
-            for i in range(batch_size):
-                i_const = self.scratch_const(i)
-                # idx = mem[inp_indices_p + i]
-                body.append(("alu", ("+", tmp_addr, self.scratch["inp_indices_p"], i_const)))
-                body.append(("load", ("load", tmp_idx, tmp_addr)))
-                body.append(("debug", ("compare", tmp_idx, (round, i, "idx"))))
-                # val = mem[inp_values_p + i]
-                body.append(("alu", ("+", tmp_addr, self.scratch["inp_values_p"], i_const)))
-                body.append(("load", ("load", tmp_val, tmp_addr)))
-                body.append(("debug", ("compare", tmp_val, (round, i, "val"))))
-                # node_val = mem[forest_values_p + idx]
-                body.append(("alu", ("+", tmp_addr, self.scratch["forest_values_p"], tmp_idx)))
-                body.append(("load", ("load", tmp_node_val, tmp_addr)))
-                body.append(("debug", ("compare", tmp_node_val, (round, i, "node_val"))))
-                # val = myhash(val ^ node_val)
-                body.append(("alu", ("^", tmp_val, tmp_val, tmp_node_val)))
-                body.extend(self.build_hash(tmp_val, tmp1, tmp2, round, i))
-                body.append(("debug", ("compare", tmp_val, (round, i, "hashed_val"))))
-                # idx = 2*idx + (1 if val % 2 == 0 else 2)
-                body.append(("alu", ("%", tmp1, tmp_val, two_const)))
-                body.append(("alu", ("==", tmp1, tmp1, zero_const)))
-                body.append(("flow", ("select", tmp3, tmp1, one_const, two_const)))
-                body.append(("alu", ("*", tmp_idx, tmp_idx, two_const)))
-                body.append(("alu", ("+", tmp_idx, tmp_idx, tmp3)))
-                body.append(("debug", ("compare", tmp_idx, (round, i, "next_idx"))))
-                # idx = 0 if idx >= n_nodes else idx
-                body.append(("alu", ("<", tmp1, tmp_idx, self.scratch["n_nodes"])))
-                body.append(("flow", ("select", tmp_idx, tmp1, tmp_idx, zero_const)))
-                body.append(("debug", ("compare", tmp_idx, (round, i, "wrapped_idx"))))
-                # mem[inp_indices_p + i] = idx
-                body.append(("alu", ("+", tmp_addr, self.scratch["inp_indices_p"], i_const)))
-                body.append(("store", ("store", tmp_addr, tmp_idx)))
-                # mem[inp_values_p + i] = val
-                body.append(("alu", ("+", tmp_addr, self.scratch["inp_values_p"], i_const)))
-                body.append(("store", ("store", tmp_addr, tmp_val)))
-
-        body_instrs = self.build(body)
-        self.instrs.extend(body_instrs)
-        # Required to match with the yield in reference_kernel2
-        self.instrs.append({"flow": [("pause",)]})
 
 BASELINE = 147734
 
